/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. RuleExpression.jj */
/*@egen*//*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

options
{
                 
                 
                             
    STATIC = false;
}

PARSER_BEGIN(RuleExpression)

/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

package com.aws.greengrass.device.configuration.parser;

public class RuleExpression/*@bgen(jjtree)*/implements RuleExpressionTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTRuleExpressionState jjtree = new JJTRuleExpressionState();

/*@egen*/
}
PARSER_END(RuleExpression)

SKIP :
{
    " "
|   "\r"
|   "\t"
}
TOKEN:
{
    < OR:           "OR" >
|   < AND:          "AND" >
|   < THINGNAME:    (<ALPHANUMERIC> | "-" | "_" | "\\:")+("*")? | "*" > // Only allow escaped colons
|   < ALPHANUMERIC: [ "a"-"z" ] | [ "A"-"Z" ] | [ "0"-"9" ] >
}

ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    expression() <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void expression(): {}
{
    logicalORExpression()
}

void logicalORExpression(): {}
{/*@bgen(jjtree) #Or(> 1) */
  {
    ASTOr jjtn001 = new ASTOr(JJTOR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    logicalANDExpression() [ <OR> logicalORExpression() ]
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/        
}

void logicalANDExpression(): {}
{/*@bgen(jjtree) #And(> 1) */
  {
    ASTAnd jjtn001 = new ASTAnd(JJTAND);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    unaryExpression() [ <AND> logicalANDExpression() ]
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/         
}

void unaryExpression(): {}
{
    // Only Thing expressions, to start
    thingExpression()
}

void thingExpression()        :
{/*@bgen(jjtree) Thing */
    ASTThing jjtn000 = new ASTThing(JJTTHING);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Thing */
    try {
/*@egen*/
    "thingName:" t=<THINGNAME>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.value = t.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}